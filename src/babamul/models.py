"""Pydantic models for BOOM alerts."""
import gzip
import io

from datetime import timezone
from astropy.io import fits
from astropy.time import Time
from .raw_models import (
    EnrichedZtfAlert,
    ZtfPhotometry,
    ZtfCandidate,
    LsstCandidate,
    LsstPhotometry,
    EnrichedLsstAlert,
)

# here we just want to re-export the raw model we autogenerated from
# avro using pydantic-avro, as the main model
# to which we add extra functions, like a `get_photometry` accessor
# that takes care of combining the different photometry sources
# (prv_candidates, prv_nondetections, fp_hists)
class BabamulZtfAlert(EnrichedZtfAlert):
    """Pydantic model for a BOOM ZTF alert."""

    def get_photometry(self, deduplicated: bool = True) -> list[ZtfPhotometry]:
        """Combine and return all photometry data from the alert."""
        photometry = []
        # Add prv_candidates photometry
        photometry.extend(self.prv_candidates)
        # Add fp_hists photometry if available
        photometry.extend(self.fp_hists)
        # Add prv_nondetections photometry
        photometry.extend(self.prv_nondetections)
        # Add fp_hists photometry if available
        photometry.extend(self.fp_hists)

        # Sort photometry by Julian Date (jd)
        photometry.sort(key=lambda x: x.jd)
        
        # if deduplicated, remove duplicates based on (jd, band)
        if deduplicated:
            seen = set()
            deduped_photometry = []
            for p in photometry:
                key = (p.jd, p.band)
                if key not in seen:
                    seen.add(key)
                    deduped_photometry.append(p)
            photometry = deduped_photometry

        return photometry
    
    # let's add a `survey` property for convenience
    @property
    def survey(self) -> str:
        return "ZTF"
    
    @property
    def drb(self) -> float | None:
        """Return the reliability (DRB) score of the candidate, if available."""
        return self.candidate.drb

    def show_cutouts(self) -> None:
        """Display the science, template, and difference cutouts.

        Requires matplotlib to be installed: pip install babamul[matplotlib]
        """
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError(
                "matplotlib is required to display cutouts. "
                "Install it with: pip install babamul[matplotlib]"
            )

        cutouts = [
            ("Science", self.cutoutScience),
            ("Template", self.cutoutTemplate),
            ("Difference", self.cutoutDifference),
        ]

        if not all(data is not None for _, data in cutouts):
            print("Some cutouts are missing for this alert.")
            return

        fig, axes = plt.subplots(1, 3, figsize=(12, 4))
        for ax, (title, data) in zip(axes, cutouts):
            with fits.open(io.BytesIO(gzip.decompress(data))) as hdu:
                ax.imshow(hdu[0].data, cmap="gray", origin="lower")
                ax.set_title(title)
                ax.axis("off")

        fig.suptitle(f"{self.objectId}")
        plt.tight_layout()
        plt.show()

ZtfCandidate.datetime = property(
    lambda self: Time(self.jd, format="jd").to_datetime(timezone=timezone.utc)
)
ZtfPhotometry.datetime = property(
    lambda self: Time(self.jd, format="jd").to_datetime(timezone=timezone.utc)
)

class BabamulLsstAlert(EnrichedLsstAlert):
    """Pydantic model for a BOOM LSST alert."""
    
    def get_photometry(self, deduplicated: bool = True) -> list[LsstPhotometry]:
        """Combine and return all photometry data from the alert."""
        photometry = []
        # Add prv_candidates photometry
        photometry.extend(self.prv_candidates)
        # Add fp_hists photometry if available
        photometry.extend(self.fp_hists)

        # Sort photometry by Julian Date (jd)
        photometry.sort(key=lambda x: x.jd)
        
        # if deduplicated, remove duplicates based on (jd, band)
        if deduplicated:
            seen = set()
            deduped_photometry = []
            for p in photometry:
                key = (p.jd, p.band)
                if key not in seen:
                    seen.add(key)
                    deduped_photometry.append(p)
            photometry = deduped_photometry

        return photometry
    
    # let's add a `survey` property for convenience
    @property
    def survey(self) -> str:
        return "LSST"
    
    @property
    def drb(self) -> float | None:
        """Return the reliability (DRB) score of the candidate, if available."""
        return self.candidate.reliability

    def show_cutouts(self) -> None:
        """Display the science, template, and difference cutouts.

        Requires matplotlib to be installed: pip install babamul[matplotlib]
        """
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError(
                "matplotlib is required to display cutouts. "
                "Install it with: pip install babamul[matplotlib]"
            )

        cutouts = [
            ("Science", self.cutoutScience),
            ("Template", self.cutoutTemplate),
            ("Difference", self.cutoutDifference),
        ]

        if not all(data is not None for _, data in cutouts):
            print("Some cutouts are missing for this alert.")
            return

        fig, axes = plt.subplots(1, 3, figsize=(12, 4))
        for ax, (title, data) in zip(axes, cutouts):
            with fits.open(io.BytesIO(gzip.decompress(data))) as hdu:
                ax.imshow(hdu[0].data, cmap="gray", origin="lower")
                ax.set_title(title)
                ax.axis("off")

        fig.suptitle(f"{self.objectId}")
        plt.tight_layout()
        plt.show()

LsstCandidate.datetime = property(
    lambda self: Time(self.jd, format="jd").to_datetime(timezone=timezone.utc)
)
LsstPhotometry.datetime = property(
    lambda self: Time(self.jd, format="jd").to_datetime(timezone=timezone.utc)
)